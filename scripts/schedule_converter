#!/usr/bin/env python
import argparse
import os
import sys
import re
import logging
from schedules_tools.converter import ScheduleConverter
from schedules_tools import discovery
from schedules_tools.discovery import search_paths
from schedules_tools.storage_handlers import AcquireLockException

logger = logging.getLogger(__name__)
handler_class_template = re.compile('^ScheduleHandler_(\S+)$')
VALID_MODULE_NAME = re.compile(r'^(\w+)\.py$', re.IGNORECASE)


def setup_logging(level):
    log_format = '%(name)-10s %(levelname)7s: %(message)s'
    sh = logging.StreamHandler(sys.stdout)
    sh.setLevel(level)

    formatter = logging.Formatter(log_format)
    sh.setFormatter(formatter)

    # setup root logger
    inst = logging.getLogger('')
    inst.setLevel(level)
    inst.addHandler(sh)


def main(args):
    handlers_args_def = '--handlers-path',
    handlers_kwargs_def = {
        'help': 'Add python-dot-notation path to discover handlers (needs to '
                'be python module), can be called several times '
                '(conflicting names will be overriden - the last '
                'implementation will be used)',
        'action': 'append',
        'default': []
    }
    setup_logging(logging.DEBUG)
    converter = ScheduleConverter()

    # Separate parser to handle '--handlers-path' argument and prepare
    # converter.provided_exports to be used in main parser
    add_handler_parser = argparse.ArgumentParser(add_help=False)
    add_handler_parser.add_argument(*handlers_args_def, **handlers_kwargs_def)
    known_args = add_handler_parser.parse_known_args(args)

    opt_args = vars(known_args[0])  # 0. index contains successfully parsed args
    for path in opt_args.pop('handlers_path'):
        search_paths.append(path)

    parser = argparse.ArgumentParser(description='Perform schedule conversions.')

    parser.add_argument(*handlers_args_def, **handlers_kwargs_def)

    parser.add_argument('-f', '--force',
                        help='Force target overwrite',
                        default=False,
                        action='store_true')

    parser.add_argument('--slug', metavar='SCHEDULE_SLUG',
                        help='Override schedule slug (e.g. rhel)')
    parser.add_argument('--use-tji-file',
                        help='Use TJI file when exporting into TJP',
                        default=False,
                        action='store_true')

    parser.add_argument('--rally-iter', help='Rally iteration to import',
                        default='')

    parser.add_argument('--check-taskname',
                        help='Check existence given task name as exact match '
                             '(can be used multiple times)',
                        action='append', metavar='TASKNAME', default=[])
    parser.add_argument('--check-taskname-startswith',
                        help='Check existence given task by matching beginning '
                             'name (can be used multiple times)',
                        action='append', metavar='TASKNAME_STARTSWITH',
                        default=[])

    parser.add_argument('--source-storage-format',
                        choices=discovery.storage_handlers.keys(),
                        metavar='SRC_STORAGE_FORMAT',
                        help='Source storage format to use')
    parser.add_argument('--cvs-repo-name',
                        help='Name of CVS repository to checkout')
    parser.add_argument('--cvs-root',
                        help='Root of CVS repository')
    parser.add_argument('--cvs-checkout-path',
                        help='Path to shared working copy of CVS repository')
    parser.add_argument('--cvs-exclusive-access',
                        help='Restrict to run just one CVS command at the same time',
                        action='store_true')
    parser.add_argument('--cvs-lock-redis-uri',
                        help='Redis URI that is required by --cvs-exclusive-access, default: localhost:6379/0',
                        default='localhost:6379/0')
    parser.add_argument('--smartsheet-token',
                        help='Access token for using SmartSheet API')
    
    parser.add_argument('--date-format',
                        help='Date format used for export where applicable')    
    
    parser.add_argument('--source-format',
                        choices=discovery.schedule_handlers.keys(),
                        metavar='SRC_FORMAT',
                        help='Source format to enforce')
    parser.add_argument('source',
                        help='Source handle (file/URL/...)',
                        type=str,
                        metavar='SRC')

    parser.add_argument('target_format',
                        choices=discovery.schedule_handlers.provided_exports,
                        metavar='TARGET_FORMAT',
                        help='Target format to convert')
    parser.add_argument('target', metavar='TARGET',
                        help='Output target', default=None, nargs='?')
    
    parser.add_argument('--flat',
                        help='Make output schedule flat',
                        default=False,
                        action='store_true')
    
    parser.add_argument('--flag-show',
                        help='Filter schedule - show tasks with any of these flags',
                        default='',
                        )
    parser.add_argument('--flag-hide',
                        help='Filter schedule - hide tasks with any of these flags, hide has preferrence over show',
                        default='',
                        )

    arguments = parser.parse_args(args)
    opt_args = vars(arguments)

    # --handlers-path argument is already procesed, it shouldn't be passed
    # as opt_args into handlers
    opt_args.pop('handlers_path')

    try:
        converter.import_schedule(handle=arguments.source,
                                  schedule_src_format=arguments.source_format,
                                  storage_src_format=arguments.source_storage_format,
                                  options=opt_args)
    except AcquireLockException as e:
        logger.error(e)
        sys.exit(1)

    check_tasks = dict()
    for task_name in arguments.check_taskname:
        check_tasks[task_name] = False

    for task_name in arguments.check_taskname_startswith:
        check_tasks[task_name] = True

    if arguments.check_taskname or arguments.check_taskname_startswith:
        missing_tasks = converter.schedule.check_for_taskname(check_tasks)
        if missing_tasks:
            logger.info('Missing tasks: {}'.format(list(missing_tasks)))

    if arguments.flat:
        converter.schedule.make_flat()
        
    flag_show = arguments.flag_show.split(',')
    if flag_show == ['']:
        flag_show = []        

    flag_hide = [f for f in arguments.flag_hide.split(',') if f]
    if flag_hide == ['']:
        flag_hide = []  
        
    converter.schedule.filter_flags(flag_show, flag_hide)      

    converter.export_schedule(arguments.target,
                              arguments.target_format,
                              options=opt_args)


if __name__ == '__main__':
    main(sys.argv[1:])
